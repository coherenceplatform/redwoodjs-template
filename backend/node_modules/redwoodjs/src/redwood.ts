import { h, render, VNode } from "preact";

export const none = Symbol("none");

let _update;
let _globalState;
let _rootComponent;
let _rootElement;
let _lastRenderedElement;
function updateTree() {
  _lastRenderedElement = render(
    h(_rootComponent, { model: _globalState }),
    _rootElement,
    _lastRenderedElement
  );
}

interface _RedwoodMessage {
  type: symbol,
  value: any,
}

function isCommand(cmd) {
  return typeof RedwoodMessageType(cmd) === "symbol";
}

function assertCommand(cmd) {
  if (!cmd) {
    throw new Error(`Received an undefined command`);
  }

  if (!isCommand(cmd)) {
    throw new Error(`Received a message with a non-symbol command: ${cmd.toString()}

Note: If this is a symbol, it should be wrapped in a RedwoodMessage().`);
  }
}
export async function dispatch(msg: _RedwoodMessage) {
  assertCommand(msg);
  let updateResults = await _update(_globalState, msg);

  while (updateResults && RedwoodMessageType(updateResults.cmd) !== none) {
    const nextCommand = updateResults.cmd;

    if (isCommand(nextCommand)) {
      assertCommand(updateResults.cmd);
      updateResults = await _update(updateResults.state, updateResults.cmd);
    } else if (nextCommand instanceof Promise) {
      _globalState = updateResults.state;
      updateTree();

      // Wait for the next command to resolve
      let resolvedCommand = await nextCommand;
      assertCommand(resolvedCommand);
      updateResults = await _update(updateResults.state, resolvedCommand);
    }
  }

  _globalState = updateResults.state;

  updateTree();
}

export function RedwoodComponent<S, D>(component: (S, D) => VNode<any>) {
  const isFunctional =
    typeof component === "function" &&
    Function.prototype.toString.call(component).indexOf("class") !== 0;

  if (!isFunctional) {
    throw new Error("RedwoodComponents must be functions, not classes.");
  }

  return props => {
    return component(props, dispatch);
  };
}

export function RedwoodMessage(symbol, value = null): _RedwoodMessage {
  if (!symbol || typeof symbol !== "symbol") {
    throw new Error("First argument must be a symbol.");
  }

  return {
    type: symbol,
    value
  };
}

export function RedwoodMessageType(message) {
  return message && message.type;
}

export function RedwoodMessageValue(message) {
  return message && message.value;
}

export function RedwoodBootstrap(
  el,
  rootComponent,
  initialState,
  update,
  initialMsg = null
) {
  _rootElement = el;
  _rootComponent = rootComponent;
  _globalState = initialState;
  _update = update;

  if (initialMsg) {
    dispatch(initialMsg);
  }

  return {
    mount: () => updateTree()
  };
}
